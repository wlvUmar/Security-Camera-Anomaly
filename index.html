<!DOCTYPE html>
<html>
<head>
  <title>Fast Camera Stream</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: white;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    h2 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 2em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .video-container {
      position: relative;
      max-width: 640px;
      margin: 0 auto;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    
    video {
      width: 100%;
      height: auto;
      display: block;
      background: #000;
    }
    
    .status-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.9em;
      font-weight: bold;
    }
    
    .status-connected { background: rgba(34, 197, 94, 0.8); }
    .status-disconnected { background: rgba(239, 68, 68, 0.8); }
    .status-connecting { background: rgba(251, 191, 36, 0.8); }
    
    canvas { display: none; }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin: 30px 0;
    }
    
    .stat-card {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      backdrop-filter: blur(5px);
    }
    
    .stat-value {
      font-size: 2em;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 0.9em;
      opacity: 0.8;
    }
    
    #log {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      padding: 20px;
      margin-top: 20px;
      height: 200px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      line-height: 1.4;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    #log::-webkit-scrollbar {
      width: 8px;
    }
    
    #log::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }
    
    #log::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin: 20px 0;
    }
    
    button {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 10px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    
    button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    @media (max-width: 768px) {
      .container { padding: 20px; margin: 10px; }
      .stats-grid { grid-template-columns: 1fr; }
      .controls { flex-direction: column; align-items: center; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üì∑ High-Performance Camera Stream</h2>
    
    <div class="video-container">
      <video id="video" autoplay playsinline muted></video>
      <div id="status" class="status-overlay status-connecting">Connecting...</div>
    </div>
    
    <div class="controls">
      <button id="reconnectBtn" onclick="reconnect()">üîÑ Reconnect</button>
      <button id="qualityBtn" onclick="toggleQuality()">üìä Quality: Medium</button>
      <button id="clearLogBtn" onclick="clearLog()">üóëÔ∏è Clear Log</button>
    </div>
    
    <div class="stats-grid">
      <div class="stat-card">
        <div id="fpsValue" class="stat-value">0</div>
        <div class="stat-label">FPS</div>
      </div>
      <div class="stat-card">
        <div id="totalFrames" class="stat-value">0</div>
        <div class="stat-label">Total Frames</div>
      </div>
      <div class="stat-card">
        <div id="avgFps" class="stat-value">0</div>
        <div class="stat-label">Avg FPS</div>
      </div>
      <div class="stat-card">
        <div id="dataRate" class="stat-value">0</div>
        <div class="stat-label">KB/s</div>
      </div>
    </div>
    
    <div id="log"></div>
    <canvas id="canvas" width="320" height="240"></canvas>
  </div>

  <script>
    // DOM elements
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d", { alpha: false });
    const statusEl = document.getElementById("status");
    
    // Performance optimization
    let ws = null;
    let reconnectInterval = 2000;
    let frameCount = 0;
    let totalFrames = 0;
    let lastTime = Date.now();
    let startTime = Date.now();
    let bytesSent = 0;
    let lastDataTime = Date.now();
    let currentQuality = 0.5;
    let isStreaming = false;
    let animationFrameId = null;
    
    // Quality presets optimized for performance
    const qualityPresets = [
      { quality: 0.2, label: "Low" },
      { quality: 0.4, label: "Medium" },
      { quality: 0.6, label: "High" }
    ];
    let currentQualityIndex = 0; // Start with lowest quality for best performance
    
    // Logging function with performance optimization
    const logMessages = [];
    const maxLogMessages = 100;
    
    const log = msg => {
      const timestamp = new Date().toLocaleTimeString();
      const message = `[${timestamp}] ${msg}`;
      
      logMessages.push(message);
      if (logMessages.length > maxLogMessages) {
        logMessages.shift();
      }
      
      const logBox = document.getElementById("log");
      logBox.textContent = logMessages.join('\n');
      logBox.scrollTop = logBox.scrollHeight;
    };
    
    // Update status indicator
    const updateStatus = (status, message) => {
      statusEl.className = `status-overlay status-${status}`;
      statusEl.textContent = message;
    };
    
    // Update statistics
    const updateStats = () => {
      const now = Date.now();
      const elapsed = (now - startTime) / 1000;
      const avgFps = totalFrames / elapsed;
      const dataRate = bytesSent / ((now - lastDataTime) / 1000) / 1024;
      
      document.getElementById("fpsValue").textContent = Math.round(frameCount);
      document.getElementById("totalFrames").textContent = totalFrames;
      document.getElementById("avgFps").textContent = Math.round(avgFps * 10) / 10;
      document.getElementById("dataRate").textContent = Math.round(dataRate);
    };
    
    // WebSocket connection with improved error handling
    const connectWebSocket = () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
      
      updateStatus('connecting', 'Connecting...');
      log("üîÑ Connecting to WebSocket...");
      
      ws = new WebSocket("wss://9558-2a05-45c2-1021-d700-5032-d3a1-5cce-72fc.ngrok-free.app/stream/video");
      
      ws.onopen = () => {
        log("‚úÖ WebSocket connected successfully");
        updateStatus('connected', 'Connected');
        if (video.srcObject && !isStreaming) {
          startSendingFrames();
        }
      };
      
      ws.onerror = err => {
        log("‚ùå WebSocket error occurred");
        updateStatus('disconnected', 'Error');
      };
      
      ws.onclose = (event) => {
        isStreaming = false;
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        
        if (event.wasClean) {
          log("üîå WebSocket closed cleanly");
        } else {
          log(`üîå WebSocket closed unexpectedly (${event.code})`);
        }
        
        updateStatus('disconnected', 'Disconnected');
        
        // Auto-reconnect
        setTimeout(() => {
          if (!ws || ws.readyState === WebSocket.CLOSED) {
            connectWebSocket();
          }
        }, reconnectInterval);
      };
    };
    
    // High-performance frame sending without throttling
    const startSendingFrames = () => {
      if (isStreaming || !video.srcObject) return;
      
      isStreaming = true;
      let isProcessing = false;
      
      const sendFrame = () => {
        if (!isStreaming || !ws || ws.readyState !== WebSocket.OPEN) {
          return;
        }
        
        // Skip frame if still processing previous one
        if (isProcessing) {
          animationFrameId = requestAnimationFrame(sendFrame);
          return;
        }
        
        isProcessing = true;
        
        // Draw frame to canvas
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Convert to blob asynchronously
        canvas.toBlob(blob => {
          if (blob && ws.readyState === WebSocket.OPEN) {
            blob.arrayBuffer().then(buffer => {
              ws.send(buffer);
              
              // Update statistics
              frameCount++;
              totalFrames++;
              bytesSent += buffer.byteLength;
              
              const now = Date.now();
              if (now - lastTime >= 1000) {
                log(`üì§ Streaming at ${frameCount} FPS | Quality: ${qualityPresets[currentQualityIndex].label}`);
                updateStats();
                frameCount = 0;
                lastTime = now;
                lastDataTime = now;
                bytesSent = 0;
              }
              
              isProcessing = false;
              animationFrameId = requestAnimationFrame(sendFrame);
            }).catch(err => {
              log("‚ùå Error processing frame: " + err.message);
              isProcessing = false;
              animationFrameId = requestAnimationFrame(sendFrame);
            });
          } else {
            isProcessing = false;
            animationFrameId = requestAnimationFrame(sendFrame);
          }
        }, 'image/jpeg', currentQuality);
      };
      
      animationFrameId = requestAnimationFrame(sendFrame);
    };
    
    // Initialize camera with performance-focused constraints
    const initCamera = async () => {
      try {
        updateStatus('connecting', 'Accessing camera...');
        
        const constraints = {
          video: {
            width: { ideal: 320, max: 640 },
            height: { ideal: 240, max: 480 },
            frameRate: { ideal: 30, min: 15 }
          }
        };
        
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        
        video.onloadedmetadata = () => {
          log(`üìπ Camera initialized: ${video.videoWidth}x${video.videoHeight}`);
          // Set canvas to smaller size for better performance
          canvas.width = Math.min(video.videoWidth, 320);
          canvas.height = Math.min(video.videoHeight, 240);
          connectWebSocket();
        };
        
      } catch (err) {
        log("‚ùå Camera access denied: " + err.message);
        updateStatus('disconnected', 'Camera Error');
      }
    };
    
    // Control functions
    window.reconnect = () => {
      connectWebSocket();
    };
    
    window.toggleQuality = () => {
      currentQualityIndex = (currentQualityIndex + 1) % qualityPresets.length;
      currentQuality = qualityPresets[currentQualityIndex].quality;
      document.getElementById("qualityBtn").textContent = `üìä Quality: ${qualityPresets[currentQualityIndex].label}`;
      log(`üéØ Quality changed to: ${qualityPresets[currentQualityIndex].label}`);
    };
    
    window.clearLog = () => {
      logMessages.length = 0;
      document.getElementById("log").textContent = '';
    };
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      initCamera();
      
      // Update stats every second
      setInterval(updateStats, 1000);
    });
    
    // Handle visibility changes for performance
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Pause streaming when tab is hidden
        if (isStreaming) {
          isStreaming = false;
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
          }
          log("‚è∏Ô∏è Streaming paused (tab hidden)");
        }
      } else {
        // Resume streaming when tab becomes visible
        if (ws && ws.readyState === WebSocket.OPEN && video.srcObject) {
          log("‚ñ∂Ô∏è Streaming resumed (tab visible)");
          startSendingFrames();
        }
      }
    });
  </script>
</body>
</html>